<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>电子商务 | MinGoBlog</title><meta name="description" content="写作电子商务，读作C-sharp"><meta name="keywords" content="电子商务,C#"><meta name="author" content="MinGo"><meta name="copyright" content="MinGo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE/G181.png"><link rel="canonical" href="http://the-mingo.club/post/8f51f577.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta property="og:type" content="article"><meta property="og:title" content="电子商务"><meta property="og:url" content="http://the-mingo.club/post/8f51f577.html"><meta property="og:site_name" content="MinGoBlog"><meta property="og:description" content="写作电子商务，读作C-sharp"><meta property="og:image" content="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-top-img.jpg"><meta property="article:published_time" content="2020-08-18T17:31:04.000Z"><meta property="article:modified_time" content="2020-08-31T11:48:30.687Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: undefined,
  copyright: {"limitCount":500,"languages":{"author":"作者: MinGo","link":"链接: ","source":"来源: MinGoBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isSidebar:!0,postUpdate:"2020-08-31 19:48:30"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}</style></noscript><script>var activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")},autoChangeMode="false",t=saveToLocal.get("theme");if("1"===autoChangeMode){var isDarkMode=window.matchMedia("(prefers-color-scheme: dark)").matches,isLightMode=window.matchMedia("(prefers-color-scheme: light)").matches,isNotSpecified=window.matchMedia("(prefers-color-scheme: no-preference)").matches,hasNoSupport=!isDarkMode&&!isLightMode&&!isNotSpecified;if(void 0===t){if(isLightMode)activateLightMode();else if(isDarkMode)activateDarkMode();else if(isNotSpecified||hasNoSupport){var now=new Date,hour=now.getHours(),isNight=hour<=6||18<=hour;isNight?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())})}else"light"===t?activateLightMode():activateDarkMode()}else"2"===autoChangeMode?(isNight=(hour=(now=new Date).getHours())<=6||18<=hour,void 0===t?isNight?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode()):"dark"===t?activateDarkMode():"light"===t&&activateLightMode()</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE/rose.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-braille"></i> <span>图墙</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E6%A6%82%E8%BF%B0"><span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AFobject-technology"><span class="toc-text">1.1.面向对象技术(Object Technology)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E7%BD%91%E7%BB%9C%E5%92%8C%E4%B8%87%E7%BB%B4%E7%BD%91"><span class="toc-text">1.2.网络和万维网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13microsoft-net"><span class="toc-text">1.3.Microsoft .NET</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vs"><span class="toc-text">2.如何使用VS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3c%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8"><span class="toc-text">3.C#简单入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E7%A8%8B%E5%BA%8F"><span class="toc-text">3.1.控制台输出程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5"><span class="toc-text">3.2.控制台输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADif"><span class="toc-text">3.3.条件判断if</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">4.1.类中的方法和对象的实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E5%A3%B0%E6%98%8E%E5%90%AB%E5%8F%82%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.声明含参方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-text">4.3.实例变量和属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.4.值类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.5.使用构造函数初始化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%97%E5%92%8C%E5%8D%81%E8%BF%9B%E5%88%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.6.浮点数字和十进制类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A51"><span class="toc-text">5.控制语句1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95"><span class="toc-text">5.1.什么是算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E8%AE%A1%E6%95%B0%E5%99%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-text">5.2.计数器控制的循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E5%93%A8%E5%85%B5%E6%8E%A7%E5%88%B6%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-text">5.3.哨兵控制的循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A52"><span class="toc-text">6.控制语句2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61for%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">6.1.for循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">6.3.逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="toc-text">6.4.结构化编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E6%96%B9%E6%B3%95"><span class="toc-text">7.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71c%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85"><span class="toc-text">7.1.C#中的代码打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72math%E7%B1%BB"><span class="toc-text">7.2.Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73%E5%85%B7%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">7.3.具有多个参数的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88"><span class="toc-text">7.4.方法调用堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">7.5.数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76net%E6%9E%84%E6%9E%B6%E7%B1%BB%E5%BA%93"><span class="toc-text">7.6.NET构架类库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">7.7.声明的作用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">7.8.方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79%E9%80%92%E5%BD%92"><span class="toc-text">7.9.递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#710%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-text">7.10.值传递与引用传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E6%95%B0%E7%BB%84"><span class="toc-text">8.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#81%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9B%E5%BB%BA"><span class="toc-text">8.1.数组的声明和创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82foreach"><span class="toc-text">8.2.foreach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">8.3.多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">8.4.命令行参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9linq%E5%92%8C%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88"><span class="toc-text">9.LINQ和泛型集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#91%E4%BD%BF%E7%94%A8linq%E6%9F%A5%E8%AF%A2%E6%95%B0%E7%BB%84"><span class="toc-text">9.1.使用LINQ查询数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92%E9%9B%86%E5%90%88"><span class="toc-text">9.2.集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">10.类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#101%E6%8E%A7%E5%88%B6%E5%AF%B9%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">10.1.控制对类成员的访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-text">10.2.索引器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">10.3.构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E6%9E%90%E6%9E%84%E5%99%A8"><span class="toc-text">10.4.垃圾收集和析构器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105%E9%9D%99%E6%80%81%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">10.5.静态类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106%E5%8F%AA%E8%AF%BB%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-text">10.6.只读实例变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107%E8%BD%AF%E4%BB%B6%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7"><span class="toc-text">10.7.软件可复用性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1%E5%92%8C%E5%B0%81%E8%A3%85"><span class="toc-text">10.8.数据抽象和封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#109%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE"><span class="toc-text">10.9.内部访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1010%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">10.10.对象的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1011lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">10.11.Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1012%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">10.12.匿名类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E7%BB%A7%E6%89%BF"><span class="toc-text">11.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#111%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">11.1.基类和派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112%E5%8F%97%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98"><span class="toc-text">11.2.受保护成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">11.3.基类和派生类的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">11.4.派生类中的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#115%E7%BB%A7%E6%89%BF%E5%9C%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">11.5.继承在软件工程中的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116object%E7%B1%BB"><span class="toc-text">11.6.Object类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E5%A4%9A%E6%80%81%E6%80%A7-%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%87%E8%BD%BD"><span class="toc-text">12.多态性、接口和运算符过载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">12.1.多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">12.2.抽象类和抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#123%E5%AF%86%E5%B0%81%E7%B1%BB%E5%92%8C%E5%AF%86%E5%B0%81%E6%96%B9%E6%B3%95"><span class="toc-text">12.3.密封类和密封方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124%E6%8E%A5%E5%8F%A3"><span class="toc-text">12.4.接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#125%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%87%E8%BD%BD"><span class="toc-text">12.5.运算符过载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">13.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#131try-catch%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-text">13.1.try-catch语句块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#132%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%9E%8B"><span class="toc-text">13.2.异常处理的终止模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#133net%E5%BC%82%E5%B8%B8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">13.3.NET异常层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134finally%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-text">13.4.finally语句块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135exception%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">13.5.Exception类的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">13.6.用户定义的异常类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14winform%E7%AA%97%E4%BD%93"><span class="toc-text">14.WinForm窗体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#141windows%E7%AA%97%E4%BD%93"><span class="toc-text">14.1.Windows窗体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">14.2.事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#143control%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E5%B8%83%E5%B1%80"><span class="toc-text">14.3.Control的属性和布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#144%E6%A0%87%E7%AD%BE-%E6%96%87%E6%9C%AC%E6%A1%86%E5%92%8C%E6%8C%89%E9%92%AE"><span class="toc-text">14.4.标签、文本框和按钮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145groupboxes-and-panels"><span class="toc-text">14.5.GroupBoxes and Panels</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146checkboxes-and-radiobuttons"><span class="toc-text">14.6.CheckBoxes and RadioButtons</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#147pictureboxes"><span class="toc-text">14.7.PictureBoxes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#148tooltips"><span class="toc-text">14.8.ToolTips</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#149numericupdown-control"><span class="toc-text">14.9.NumericUpDown Control</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1410%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">14.10.鼠标事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1411%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">14.11.键盘事件处理</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-top-img.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">MinGoBlog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-braille"></i> <span>图墙</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">电子商务</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-18T17:31:04.000Z" title="发表于 2020-08-19 01:31:04">2020-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-31T11:48:30.687Z" title="更新于 2020-08-31 19:48:30">2020-08-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/">本科课程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.9k</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><div class="note info"><p>说是电子商务，学的其实是面向对象之C#。</p><p>写作电子商务，读作C-sharp。<strong>╮(╯-╰)╭</strong></p></div><a id="more"></a><p>还有8天就期末考试了，真正复习的时间只剩6天，也不知道复习时间够不够。<s>（想来是不够的，中途不可避免的会摸鱼）</s></p><h2 id="1概述"><a class="markdownIt-Anchor" href="#1概述"></a> 1.概述</h2><p>本章先介绍了计算机的基础知识，比如五大部件、操作系统、硬件发展趋势等，这些不太重要。</p><h3 id="11面向对象技术object-technology"><a class="markdownIt-Anchor" href="#11面向对象技术object-technology"></a> 1.1.面向对象技术(Object Technology)</h3><p>面向对象技术，是创建软件单元的分包模式。</p><p>对象包含了</p><ul><li>属性(properties/attributes)</li><li>行为(actions/behaviors/methods)</li></ul><p>类(classes)是一些相关对象的类型，共性。</p><h3 id="12网络和万维网"><a class="markdownIt-Anchor" href="#12网络和万维网"></a> 1.2.网络和万维网</h3><p>最早的网络是<code>APRAnet</code>，它率先使用了<code>e-mail</code>作为交流方式。</p><p><code>TCP</code>(Transmission Control Protocol)为交流需遵守的协议，确保了消息分包能被正确的从发送方路由到接收方。为了连接不同的网络，引入了<code>IP</code>(Internet Protocol)。这一系列的协议统称为<code>TCP/IP</code>。</p><p>万维网是与网络相关的硬件和软件的集合，<code>HTML</code>(HyperText Markup Language)是分享信息的技术，<code>HTTP</code>(HyperText Transfer Protocol)为主要的网络交流协议。<code>XML</code>(Extensible Markup Language)弥补了<code>HTML</code>在拓展性方面的缺陷，其重要特征是数据独立性。</p><h3 id="13microsoft-net"><a class="markdownIt-Anchor" href="#13microsoft-net"></a> 1.3.Microsoft .NET</h3><p><code>ASP.NET</code>可用于创建web应用。</p><p><code>.NET Framework</code>:</p><ul><li>管理并运行应用和web服务</li><li>包含了一个类库(<code>.NET Framework Class Library</code>)</li><li>提供安全性和其他编程能力</li></ul><p><code>CLR</code>(Common Language Runtime):</p><ul><li>程序先编译成<code>MSIL</code>(Microsoft Intermediate Language，微软中级语言)</li><li>应用执行时，实时编译器(just-in-time compiler)将可执行文件中的<code>MSIL</code>转化成机器语言代码</li></ul><p>.NET架构：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/.NET%E6%9E%B6%E6%9E%84.png" alt=".NET架构" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/.NET%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91.png" style="zoom:50%"><blockquote><p>CIL code：公共中间语言代码</p></blockquote><p>.NET 和Java的比较：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/.NET%E5%92%8CJava%E7%9A%84%E6%AF%94%E8%BE%83.png" style="zoom:50%"><h2 id="2如何使用vs"><a class="markdownIt-Anchor" href="#2如何使用vs"></a> 2.如何使用VS</h2><p>这章介绍了如何使用VS来编写C#代码。</p><p>重点是用语言描述创建一个C#工程的流程。</p><blockquote><ol><li>Select File &gt; New Project… to display the New Project dialog</li><li>Select the Console Application template.</li><li>In the dialog’s Name field, type Welcome1, and click OK to create the project.</li></ol></blockquote><h2 id="3c简单入门"><a class="markdownIt-Anchor" href="#3c简单入门"></a> 3.C#简单入门</h2><h3 id="31控制台输出程序"><a class="markdownIt-Anchor" href="#31控制台输出程序"></a> 3.1.控制台输出程序</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一个简单的控制台输出程序 */</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WelcomeCSharp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 主调函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Welcome to C# Programming!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#大小写敏感。</p><ol><li><p>注释：提高代码可读性</p><ul><li>单行注释(single-line comment): <code>//</code></li><li>分割注释(delimited comments): <code>/* */</code></li></ul></li><li><p>命名空间<code>namespace</code>：</p><p>包含了.cs文件所需的预定义类，.NET的命名空间被称为.NET框架类库(.NET Framework Class Library)</p></li><li><p>空白分割<code>whitespace</code>：包括了空白行和空格，编译时会被忽略。</p></li><li><p>关键字<code>keywords/reserved words</code>：小写字母</p></li><li><p>类的声明<code>class declaration</code>：类名<code>indentifier</code>采用双驼峰命名法，包含字母、数字、下划线，不以数字开头。</p></li><li><p>字符串<code>string</code>：双引号包裹</p></li><li><p><code>Console.WriteLine</code>换行，<code>Console.Write</code>不换行</p></li></ol><h3 id="32控制台输入"><a class="markdownIt-Anchor" href="#32控制台输入"></a> 3.2.控制台输入</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 控制台输入 */</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Addition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Please input a integer: &quot;</span>);</span><br><span class="line">        number = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The number is &#123;0:D&#125;&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>简单类型<code>simple types</code>：<ul><li><code>int</code></li><li><code>float</code>, <code>double</code>, <code>decimal</code></li><li><code>char</code></li></ul></li><li>变量名标识符<code>variable-name identifiers</code>采用单驼峰命名法</li><li><code>Console.ReadLine</code>获得一个用户输入的字符串，直至按下Enter键</li><li><code>=</code>是一个二进制运算符<code>binary operator</code>，作用于两个信息片段或操作数</li><li>每个变量都有一个名称<code>name</code>、类型<code>type</code>、范围<code>size</code>和值<code>value</code></li></ol><h3 id="33条件判断if"><a class="markdownIt-Anchor" href="#33条件判断if"></a> 3.3.条件判断if</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (number1 == number2) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125; == &#123;1&#125;&quot;</span>, number1, number2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (number1 != number2) &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125; != &#123;1&#125;&quot;</span>, number1, number2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符优先级</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" style="zoom:50%"><h2 id="4类和对象"><a class="markdownIt-Anchor" href="#4类和对象"></a> 4.类和对象</h2><ul><li>方法<code>Method</code>：描述描述其实际执行任务的内部机制</li><li>类<code>class</code>：包含(house)了方法</li><li>对象<code>object</code>：必须先创建类的对象，才能执行类描述的任务。通过方法调<code>method call</code>用来向对象传递消息</li><li>属性<code>attribute/property</code>：类包含了属性，而类的每个对象都保有自己的属性。属性由类的实例变量<code>instance variable</code>指定。属性不一定能直接访问，可以使用访问器<code>get accessor</code>和修改器<code>set accesssor</code>来操作属性。</li></ul><h3 id="41类中的方法和对象的实例化"><a class="markdownIt-Anchor" href="#41类中的方法和对象的实例化"></a> 4.1.类中的方法和对象的实例化</h3><p>关键字<code>public</code>是一个访问修改器<code>access modifier</code>(确定属性/方法的可访问性)，说明该属性/方法可以在类的外部调用。</p><p>任何包含<code>Main</code>方法的类都可以用来执行应用程序，静态方法<code>static method</code>无需实例化对象即可调用。</p><h3 id="42声明含参方法"><a class="markdownIt-Anchor" href="#42声明含参方法"></a> 4.2.声明含参方法</h3><p>方法可以指定参数及执行任务所需的其他信息，而方法调用为方法的每个参数<code>argument/paramenter</code>提供值<code>value</code>。</p><p>如果不说明命名空间<code>using namespace</code>，就需要使用完全限定类名<code>full qualified class name</code>，如<code>System.Console.WriteLine()</code>。</p><h3 id="43实例变量和属性"><a class="markdownIt-Anchor" href="#43实例变量和属性"></a> 4.3.实例变量和属性</h3><p>实例变量<code>local variables</code>：在方法体中声明的变量，当该方法终止时，实例对象的值被回收。</p><p>属性在类声明中表示为变量，对象的属性副本<code>copy of attributes</code>称为实例变量<code>instance variables</code>。实例变量都有一个默认的初始值<code>default initial value</code>，比如string类型变量的默认值为<code>null</code>，不显示任何文本。</p><p>使用访问修饰符<code>private</code>声明的变量、属性或方法只能在声明它们的类中访问。 声明具有访问修饰符<code>private</code>的实例变量，称为信息隐藏<code>information hiding</code>。</p><p><code>get</code>和<code>set</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        name = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可简写为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure><p>属性中的get和set可以只用一个，如果只有get而没有set，那么这个属性只可读出，不可写入；如果只有set而没有get，那么这个属性是只写入，不可读出。</p><h3 id="44值类型和引用类型"><a class="markdownIt-Anchor" href="#44值类型和引用类型"></a> 4.4.值类型和引用类型</h3><p>值类型<code>value type</code>的变量仅包含该类型的值。</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F.png" style="zoom:50%"><p>引用类型<code>reference type</code>的变量包含存储其数据的内存中位置的地址。默认情况下，引用类型的实例变量初始化为值<code>null</code>。 引用型变量用于调用(<code>invoke</code>)对象的方法并访问对象的属性。</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F.png" style="zoom:50%"><h3 id="45使用构造函数初始化对象"><a class="markdownIt-Anchor" href="#45使用构造函数初始化对象"></a> 4.5.使用构造函数初始化对象</h3><p>每个类都可以提供一个构造函数<code>constructor</code>，在创建对象时初始化类的对象。</p><p>运算符<code>new</code>调用类的构造函数以执行初始化。</p><p>编译器提供没有参数的公共默认构造函数<code>public default constructor</code>，因此每个类都有一个构造函数。</p><p>构造函数必须具有与其类相同的名称。 与方法一样，构造函数具有参数列表。</p><h3 id="46浮点数字和十进制类型"><a class="markdownIt-Anchor" href="#46浮点数字和十进制类型"></a> 4.6.浮点数字和十进制类型</h3><p>浮点类型<code>float</code>和双精度类型<code>double</code>称为浮点类型<code>floating-point type</code>。</p><p>C#将键入的应用程序源代码的所有实数视为<code>double</code>值。</p><p>十进制变量存储有限的实数范围，但更精确，更适合货币金额。</p><p>要键入十进制文本<code>decimal literal</code>，必须在实数末尾键入字母&quot;M&quot;或&quot;m&quot;。</p><p><code>&#123;0:C&#125;</code>表示输出为货币金额，<code>:</code>为格式说明符<code>format specifier</code>。<code>&#123;0, 20&#125;</code>表示以字段宽度20显示值输出，若要输出应保持左对齐<code>left justified</code>，需使用<code>&#123;0, -&#125;</code>。</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E%E7%AC%A6.png" style="zoom:50%"><h2 id="5控制语句1"><a class="markdownIt-Anchor" href="#5控制语句1"></a> 5.控制语句1</h2><p>C#中的<code>if...else</code>和<code>while</code>语句看起来和C/C++没什么不同。</p><h3 id="51什么是算法"><a class="markdownIt-Anchor" href="#51什么是算法"></a> 5.1.什么是算法</h3><p>算法<code>algorithm</code>是解决问题的过程<code>procedure</code>，包括：要执行的操作<code>actions</code>，执行这些操作的顺序<code>order</code>。</p><p>语句在程序中执行的顺序称为程序控制<code>program control</code>。</p><h3 id="52计数器控制的循环"><a class="markdownIt-Anchor" href="#52计数器控制的循环"></a> 5.2.计数器控制的循环</h3><p>称为计数器<code>counter</code>的变量控制一组语句将执行的时间。</p><p>计数器控制的重复<code>Counter-Controlled Repetition</code>通常称为确定重复<code>definite repetition</code>，因为重复次数在循环开始执行之前是已知的。</p><h3 id="53哨兵控制的循环"><a class="markdownIt-Anchor" href="#53哨兵控制的循环"></a> 5.3.哨兵控制的循环</h3><p>可以输入一个哨兵值<code>sentinel value</code>来指示&quot;数据输入结束&quot;。这称为哨兵控制重复<code>sentinel-controlled repetition</code>。 哨兵控制的重复通常称为无限期重复<code>indefinite repetition</code>，因为在循环开始之前不知道重复次数。</p><h2 id="6控制语句2"><a class="markdownIt-Anchor" href="#6控制语句2"></a> 6.控制语句2</h2><p>计数器控制的循环的基本要素：</p><ul><li>控制变量<code>control variable</code>（或循环计数器）</li><li>控制变量的初始值<code>initial value</code></li><li>控制变量的增量（或递增）<code>increment/decrement</code>修改循环的每个迭代<code>iteration of the loop</code></li><li>循环延续条件<code>loop-continuation condition</code></li></ul><h3 id="61for循环语句"><a class="markdownIt-Anchor" href="#61for循环语句"></a> 6.1.for循环语句</h3><p>变量的生命周期<code>variable’s scope</code>：如果初始化表达式时声明控制变量，则控制变量将不存在在for语句之外。同样，局部变量也只能在声明变量的方法中使用，并且只能从声明点使用。</p><p>for循环头部的三个表达式都是可选的。</p><p>C#中<code>for</code>循环、<code>do..while</code>循环、<code>switch</code>语句、<code>continue</code>、<code>break</code>的使用，与C/C++中的并无二致。</p><h3 id="62静态方法"><a class="markdownIt-Anchor" href="#62静态方法"></a> 6.2.静态方法</h3><p>许多类提供不需要在对象上调用的静态方法<code>static methods</code>。</p><p>通过指定类名后跟成员访问运算符<code>.</code>和方法名称来调用静态方法。</p><blockquote><p><em>ClassName</em>.<em>methodName</em>( <em>arguments</em> )</p></blockquote><p>若要将方法声明为静态方法，请将关键字放在方法声明的返回值类型之前。</p><p>类中声明的每个常量，但不是类方法内声明的，都是隐式静态的，因此使用关键字静态显式声明此类常量是语法错误。</p><p>创建包含静态变量的类对象时，该类的所有对象共享该类静态变量的一个副本。</p><p>静态变量和实例变量一起表示类的字段<code>fields</code>。</p><p><strong>为什么Main方法是静态的？</strong></p><ul><li>Main 方法有时称为应用程序的入口点<code>entry point</code>。</li><li>将 Main 声明为静态允许执行环境调用 Main 而不创建类的实例。</li><li>从命令行执行应用程序时，键入应用程序名称，后跟命令行参数<code>command-line arguments</code>，这些参数指定用空格分隔的字符串列表。</li><li>执行环境会将这些参数传递给应用程序的 Main 方法。</li></ul><p>此外，Main 方法可以省略关键字<code>public</code>，且在每个类中只能声明一个 Main 方法。</p><h3 id="63逻辑运算符"><a class="markdownIt-Anchor" href="#63逻辑运算符"></a> 6.3.逻辑运算符</h3><ul><li><p><code>&amp;&amp;</code>和<code>||</code>是短路评估<code>short-circuit evaluation</code></p></li><li><p><code>&amp;</code>和<code>|</code>不是短路评估</p></li><li><p>逻辑异或<code>^</code>在操作数一真一假时，才为真</p></li></ul><p>运算符优先级：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7-%E5%AE%8C%E6%95%B42.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7-%E5%AE%8C%E6%95%B42.png" style="zoom:50%"><h3 id="64结构化编程"><a class="markdownIt-Anchor" href="#64结构化编程"></a> 6.4.结构化编程</h3><p>结构化编程的规则：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B%E7%9A%84%E8%A7%84%E5%88%99.png" style="zoom:50%"><h2 id="7方法"><a class="markdownIt-Anchor" href="#7方法"></a> 7.方法</h2><p>开发和维护大型应用程序的最佳方法就是从小而简单的部分构造它。</p><p>这种技术被称为分裂和征服<code>divide and conquer</code>。</p><ul><li>通过从小而简单的部分构建应用程序，使应用程序开发更易于管理。</li><li>软件可重复性 — 现有方法可用作创建新应用程序的构建基块。</li><li>避免重复代码。</li></ul><p>将应用程序划分为有意义的方法使应用程序更易于调试和维护。</p><h3 id="71c中的代码打包"><a class="markdownIt-Anchor" href="#71c中的代码打包"></a> 7.1.C#中的代码打包</h3><p>打包代码的常见方法是属性、方法、类和命名空间。</p><p>框架类库<code>The Framework Class Library</code>提供了许多预定义的类，其中包含执行常见任务的方法。</p><h3 id="72math类"><a class="markdownIt-Anchor" href="#72math类"></a> 7.2.Math类</h3><p><code>Math</code>类中包含的静态方法：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Math%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%951.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Math%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%952.png" style="zoom:50%"><p>Math类还声明两个静态常量，表示常用的数学值：<code>Math.PI</code> 和 <code>Math.E</code>。关键字 <code>const</code>可防止在声明常量后更改其值。</p><h3 id="73具有多个参数的方法"><a class="markdownIt-Anchor" href="#73具有多个参数的方法"></a> 7.3.具有多个参数的方法</h3><p>当方法具有多个参数时，这些参数指定为逗号分隔列表。</p><p>方法调用中必须有方法声明中每个参数<code>formal parameter</code>对应的实例参数，且每个实例参数必须与相应形式参数的类型一致。</p><p>当程序控制从方法返回时，该方法的参数在内存中不再可访问。</p><p>方法最多可以返回一个值。</p><p>可以使用运算符 <code>+</code> 组合字符串。 当 <code>+</code> 运算符的一个操作数是字符串时，另一个操作数隐式转换为字符串，然后两者串联。</p><p>所有对象都有一个 <code>ToString</code>方法，该方法返回对象的字符串表示形式。当对象与字符串连接时，将隐式调用对象的 <code>ToString</code>方法以获取对象的字符串表示形式。</p><p>有三种方法可以将控件返回到调用方法的语句：</p><ul><li>到达方法的末尾。</li><li>没有值的返回语句。</li><li>具有值的返回语句。</li></ul><h3 id="74方法调用堆栈"><a class="markdownIt-Anchor" href="#74方法调用堆栈"></a> 7.4.方法调用堆栈</h3><p>当应用程序调用方法时，调用方法的返回地址将推送到程序执行堆栈<code>program-execution stack</code>。</p><p>程序执行堆栈还存储本地变量。此数据称为方法调用的激活记录或堆栈帧<code>activation record / stack frame</code>。</p><p>进行方法调用时，其激活记录将推送到程序执行堆栈。</p><p>当方法调用从堆栈中弹出时，应用程序不再知道局部变量。</p><p>如果发生这么多方法调用以使堆栈内存不足，则会发生称为堆栈溢出<code>stack overflow</code>的错误。</p><h3 id="75数据类型转换"><a class="markdownIt-Anchor" href="#75数据类型转换"></a> 7.5.数据类型转换</h3><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A1%A81.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A1%A82.png" style="zoom:50%"><h3 id="76net构架类库"><a class="markdownIt-Anchor" href="#76net构架类库"></a> 7.6.NET构架类库</h3><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/.NET%E6%9E%84%E6%9E%B6%E7%B1%BB%E5%BA%93%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.png" style="zoom:50%"><h3 id="77声明的作用范围"><a class="markdownIt-Anchor" href="#77声明的作用范围"></a> 7.7.声明的作用范围</h3><p>声明的作用范围<code>scope</code>是，应用程序中可以通过其非限定名称引用声明的实体的部分。</p><p>参数声明的范围是声明在其中显示的方法的正文。</p><p>局部变量声明的范围从声明显示到包含声明的块的末尾。</p><p>类的非静态方法、属性或字段的范围是类的整个正文。</p><p>如果方法中的局部变量或参数与字段具有相同的名称，则该字段将隐藏，直到块终止。</p><h3 id="78方法重载"><a class="markdownIt-Anchor" href="#78方法重载"></a> 7.8.方法重载</h3><p>同一名称的方法可以在同一类中声明，也可以重载<code>overloaded</code>，只要它们具有不同的参数集。</p><p>调用重载方法时，C# 编译器通过检查调用中参数的数量、类型和顺序来选择适当的方法。</p><p>方法重载用于创建几个同名的方法，这些方法执行相同的任务，但用于不同的参数类型或数量。</p><p>如果重载方法具有不同的参数列表，则重载方法可以具有相同或不同的返回类型。重载方法不必具有相同的参数个数。</p><h3 id="79递归"><a class="markdownIt-Anchor" href="#79递归"></a> 7.9.递归</h3><p>递归方法<code>recursive method</code>是调用自己的方法。递归方法只能求解基本情况。</p><p>每个方法调用将问题划分为两个概念部分：方法知道如何执行的部分和递归调用，或解决较小问题的递归步骤。</p><p>一系列返回将随之而来，直到原始方法调用将结果返回给调用方。</p><h3 id="710值传递与引用传递"><a class="markdownIt-Anchor" href="#710值传递与引用传递"></a> 7.10.值传递与引用传递</h3><p>当参数通过值传递<code>pass-by-value</code>时（C# 中的默认），将创建其值的副本并传递给被调用的函数。</p><p>当通过引用传递参数<code>pass-by-reference</code>时，调用方为该方法提供了访问和修改调用方的原始变量的能力。</p><p>引用本身按值传递，但该方法仍可以使用它接收的引用来修改内存中的原始对象。</p><p>实际上，对象始终通过引用传递。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RefExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        i = <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        Method(<span class="keyword">ref</span> val);</span><br><span class="line">        <span class="comment">// val is now 44</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">OutExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        i = <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line">        Method(<span class="keyword">out</span> <span class="keyword">value</span>);</span><br><span class="line">        <span class="comment">// value is now 44</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ref</code>和<code>out</code>的区别：</p><ul><li><p>两者都是按地址传递的，使用后都将改变原来参数的数值。</p></li><li><p>ref可以把参数的数值传递进函数，但是out是要把参数清空，就是说无法把一个数值从out传递进去的，out进去后，参数的数值为空，所以必须初始化一次。这个就是两个的区别，ref是有进有出，out是只出不进。</p></li></ul><h2 id="8数组"><a class="markdownIt-Anchor" href="#8数组"></a> 8.数组</h2><p>数据结构<code>Data structures</code>是相关数据项的集合。数组是<code>Arrays</code>由相同类型的相关数据项组成的数据结构。数组是固定长度的实体，创建数组后它们的长度保持不变。</p><p>数组是一组变量（称为元素<code>elements</code>），其中包含所有变量都具有相同的类型。</p><p>数组是引用类型，我们通常认为数组实际上是对数组对象的引用。 数组的元素可以是值类型或引用类型。</p><p>为了引用数组中的特定元素，我们指定对数组的引用的名称，该数组的元素在数组中的位置称为元素的索引<code>index</code>。索引必须是非内值整数，可以是表达式。每个数组的长度都存储在其<code>Length</code>属性中。</p><h3 id="81数组的声明和创建"><a class="markdownIt-Anchor" href="#81数组的声明和创建"></a> 8.1.数组的声明和创建</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br></pre></td></tr></table></figure><p>尽管数组是固定长度的实体，但仍可以使用静态数组方法<code>Resize</code>调整数组的大小。</p><p>调整数组大小需要两个参数 - 要调整大小的数组和新的长度。它执行以下操作：</p><ul><li>创建具有指定长度的新数组</li><li>将旧数组的内容复制到新数组中</li><li>设置数组变量以引用新数组。</li></ul><p>无法放入新数组的任何内容将被截断。</p><p>在 C# 中，访问任何数组元素将强制检查数组索引以确保其有效，这称为边界检查<code>bounds checking</code>。</p><h3 id="82foreach"><a class="markdownIt-Anchor" href="#82foreach"></a> 8.2.foreach</h3><p>foreach 语句只能用于访问数组元素，不能用于修改元素。任何更改 foreach 语句正文中迭代变量值的尝试都会导致编译错误。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">int</span> number <span class="keyword">in</span> arrayA) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> inarrayA) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>var</code>可代替任何类型，编译器会根据上下文来判断你到底是想用什么类型。</p><p>使用var定义变量时有以下四个<strong>特点</strong>:</p><ol><li><p>必须在定义时初始化。也就是必须是var s = “abcd”形式，而不能是如下形式: var s; s = “abcd”;</p></li><li><p>一但初始化完成，就不能再给变量赋与初始化值类型不同的值了。</p></li><li><p>var要求是局部变量。</p></li><li><p>使用var定义变量和object不同，它在效率上和使用强类型方式定义变量完全一样。</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CallArray(arrayA);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CallArray</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用关键字<code>ref</code>通过引用传递引用类型变量，这允许调用方法修改调用方中的原始变量，并使该变量引用其他对象。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CallArray(<span class="keyword">ref</span> arrayA);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CallArray</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span>[] array</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="83多维数组"><a class="markdownIt-Anchor" href="#83多维数组"></a> 8.3.多维数组</h3><p>可变长度参数列表<code>Variable-length argument lists</code>允许创建接收任意数量的参数的方法，必要的参数修改器只能出现在参数列表的最后一个条目中。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Function</span> (<span class="params"><span class="keyword">params</span> <span class="keyword">int</span>[] arrayA</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> number1 = <span class="number">1</span>, number2 = <span class="number">2</span>, number3 = <span class="number">3</span>;</span><br><span class="line">Function (number1);</span><br><span class="line">Function (number1, number2);</span><br><span class="line">Function (number1, number2, number3);</span><br></pre></td></tr></table></figure><h3 id="84命令行参数"><a class="markdownIt-Anchor" href="#84命令行参数"></a> 8.4.命令行参数</h3><p>通过将类型字符串的参数包括在 Main 的参数列表中，可以将命令行参数<code>command-line arguments</code>传递给应用程序，按照惯例，此参数名为<code>args</code>。</p><p>执行环境将命令行参数作为数组传递到应用程序的 Main 方法。</p><p>从命令行传递的参数个数是通过访问数组<code>args</code>的<code>Length</code>属性获得的。</p><p>命令行参数用空格而不是逗号分隔。</p><h2 id="9linq和泛型集合"><a class="markdownIt-Anchor" href="#9linq和泛型集合"></a> 9.LINQ和泛型集合</h2><p><code>LINQ</code>（Language Integrated Query )语言集成查询，是一组用于C#和VB语言的拓展，它允许VB或者C#代码以操作内存数据的方式，查询数据库。</p><p>LINQ 提供程序<code>LINQ provider</code>是一组实现 LINQ 操作的类，使程序能够与数据源交互以执行诸如投射、排序、分组和筛选元素等任务。</p><h3 id="91使用linq查询数组"><a class="markdownIt-Anchor" href="#91使用linq查询数组"></a> 9.1.使用LINQ查询数组</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] values = &#123;  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> filtered = </span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">value</span> <span class="keyword">in</span> values</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">value</span></span><br><span class="line">    <span class="keyword">where</span> number &gt; <span class="number">4</span></span><br><span class="line">    <span class="keyword">select</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sorted = </span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">value</span> <span class="keyword">in</span> values</span><br><span class="line">    <span class="keyword">orderby</span> <span class="keyword">value</span> <span class="keyword">descending</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">Display(filtered);</span><br><span class="line">DisPlay(sorted);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Display</span> (<span class="params">IEnable&lt;<span class="keyword">int</span>&gt; result</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LINQ 查询以<code>from</code>子句开头，该子句指定范围变量（值）和要查询的数据源（值）。</li><li><code>where</code>子句中的条件计算为 true，则选择元素。</li><li><code>select</code>子句确定结果中显示的值。</li><li><code>orderby</code>子句默认按升序对查询结果进行排序，可使用降序修饰符<code>descending</code>按降序对结果进行排序。</li><li><code>let</code>子句可用于创建新的范围变量，以存储临时结果，供以后在 LINQ 查询中使用。</li></ul><p>筛选数组的重复语句侧重于获取结果所需的步骤这，称为命令式编程<code>imperative programming</code>。但是，LINQ 查询指定所选元素必须满足的条件，这称为声明性编程<code>declarative programming</code>。<code>System.Linq</code>命名空间包含 LINQ 到对象提供程序。</p><p>接口<code>Interfaces</code>定义并标准化了人与系统相互交互的方式。C# 接口描述一组可以在对象上调用的方法。实现接口的类必须定义接口中的每一个方法，其签名与接口定义中的签名相同。</p><p><code>IEnumer&lt;T&gt;</code>接口描述了可以重复的任何对象的功能，从而提供了访问每个元素的方法。数组和集合已经实现<code>IEnumer&lt;T&gt;</code>接口。</p><p>LINQ 查询返回实现<code>IEnumer&lt;T&gt;</code>对象。使用 LINQ，选择元素的代码和显示元素的代码是分开的，使代码更易于理解和维护。</p><p>.NET 中的可比较类型是实现<code>IComparable&lt;T&gt;</code>。 所有内置类型，如 string、int 和 double 都实现了<code>IComparable&lt;T&gt;</code>。</p><h3 id="92集合"><a class="markdownIt-Anchor" href="#92集合"></a> 9.2.集合</h3><p>集合<code>collection</code>提供高效的方法，用于组织、存储和检索数据，而无需了解数据的存储方式。</p><p>集合类<code>List&lt;T&gt;</code>（来自命名空间<code>System.Collections.Generic</code>）不需要重新分配以更改其大小。</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E7%B1%BBList%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A71.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E9%9B%86%E5%90%88%E7%B1%BBList%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A72.png" style="zoom:50%"><p>**列表是使用幕后数组实现的。**当 List 增长时，它必须创建一个更大的内部数组，并为每个元素复制到新数组。</p><p>列表仅在添加元素且新元素没有空间时才增长。列表每次增长时其容量<code>Capacity</code>加倍。</p><h2 id="10类和对象"><a class="markdownIt-Anchor" href="#10类和对象"></a> 10.类和对象</h2><h3 id="101控制对类成员的访问"><a class="markdownIt-Anchor" href="#101控制对类成员的访问"></a> 10.1.控制对类成员的访问</h3><p>类的成员（例如属性、方法和实例变量）默认情况下具有私有访问权限。</p><p>每个对象都可以使用关键字<code>this</code>访问对自身的引用。当调用非静态方法时，该方法的正文隐式地使用关键字<code>this</code>来引用对象的实例变量和其他方法。还可以在非静态方法的正文中显式使用关键字。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span> (<span class="params"><span class="keyword">string</span> name, <span class="keyword">int</span> age</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FunctionA</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FunctionB</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        FunctionA();</span><br><span class="line">        <span class="comment">// 也可写this.FunctionA();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果构造函数的参数名称与类的实例变量名称相同，则它们隐藏相应的实例变量(即类成员变量)。可以使用<code>this</code>显式引用隐藏的实例变量。</p><p>如果未隐藏成员，则<code>this</code>关键字是隐含的，但可以显式包含。</p><h3 id="102索引器"><a class="markdownIt-Anchor" href="#102索引器"></a> 10.2.索引器</h3><p>封装<code>encapsulates</code>数据列表的类可以使用关键字来定义属性类成员，称为索引器<code>indexers</code>，允许以数组样式索引访问元素列表。</p><p>可以定义整数索引和非整数索引。索引器可以返回任何类型，即使是不同于基础数据类型的类型。与属性不同，可以选择适当的属性名称，索引器必须使用关键字 this 定义。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> names = &#123;<span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;top&quot;</span>, <span class="string">&quot;bottom&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] position = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span> (<span class="params"><span class="keyword">double</span> left, <span class="keyword">double</span> right, <span class="keyword">double</span> top, <span class="keyword">double</span> bottom</span>)</span> &#123;</span><br><span class="line">        position[<span class="number">0</span>] = left;</span><br><span class="line">        position[<span class="number">1</span>] = right;</span><br><span class="line">        position[<span class="number">2</span>] = top;</span><br><span class="line">        position[<span class="number">3</span>] = bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">this</span> (<span class="params"><span class="keyword">int</span> index</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> position[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            position[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">this</span> (<span class="params"><span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (name != names[index]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> position[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (name != names[index]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            position[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Box box = <span class="keyword">new</span> Box(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 隐式调用索引器的 get 访问器</span></span><br><span class="line">Console.WriteLine(box[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 隐式调用索引器的集访问器</span></span><br><span class="line">box[<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line">Console.WriteLine(box[<span class="string">&quot;left&quot;</span>]);</span><br></pre></td></tr></table></figure><p>索引器可以像方法一样重载。</p><h3 id="103构造函数"><a class="markdownIt-Anchor" href="#103构造函数"></a> 10.3.构造函数</h3><p>重载构造函数允许以不同的方式初始化类的对象。要重载构造函数，只需提供具有不同签名的多个构造函数声明。</p><p>每个类必须至少有一个构造函数<code>Constructor</code>。如果未在类的声明中提供任何构造函数，编译器将创建一个默认构造函数，在调用时不采用参数。</p><p>编译器不会为至少有一个构造函数的类创建默认构造函数。如果已声明构造函数，但希望能够调用没有参数的构造函数，则必须声明一个无参数构造函数。</p><p>如果类具有构造函数，但没有公共<code>piblic</code>无参数构造函数，应用程序尝试调用无参数构造函数初始化类的对象，发生编译错误。只有在类没有任何构造函数时，才能在没有参数时调用构造函数（在这种情况下，调用默认构造函数），或者如果类具有公共<code>public</code>无参数构造函数。</p><p>只有构造函数才能与类具有相同的名称。</p><p>类可以具有对其他类对象的引用作为成员。这称为组合<code>composition</code>，有时称为<code>has-a relationship</code>。软件复用<code>reuse</code>的一种形式是组合，即类具有对其他类的对象的引用成员。</p><h3 id="104垃圾收集和析构器"><a class="markdownIt-Anchor" href="#104垃圾收集和析构器"></a> 10.4.垃圾收集和析构器</h3><p>如果在显式释放资源之前丢失了对管理资源的对象的所有引用，则无法再释放该资源。这称为资源泄漏<code>resource leak</code>。</p><p>公共语言运行时（CLR）使用垃圾回收器<code>garbage collector</code>回收不再使用的对象占用的内存。当不再引用对象时，该对象将有资格被销毁<code>eligible for destruction</code>。</p><p>每个对象都有一个析构函数<code>destructor</code>，由垃圾回收器调用，在回收其内存之前执行终止内务管理<code>termination housekeeping</code>。析构函数的名称是类名称，前面有一个波浪，并且其标题中没有访问修饰符。</p><p>调用对象的析构函数后，该对象将有资格进行垃圾回收 — 垃圾回收器可以回收对象的内存。</p><p>垃圾回收器的一个问题是，它不能保证在指定时间执行其任务。因此，很少使用析构函数。</p><h3 id="105静态类成员"><a class="markdownIt-Anchor" href="#105静态类成员"></a> 10.5.静态类成员</h3><p>当类的所有对象只应共享特定变量的一个副本时，使用静态变量。</p><p>静态变量表示类范围信息 — 类的所有对象共享同一段数据。 静态变量的声明以关键字<code>static</code>开头。</p><p>静态变量的范围是其类的正文。静态变量和方法存在，并且可以使用，即使该类的对象尚未实例化。</p><p>C# 中的字符串对象是不可变的，创建后无法修改它们。因此，对一个字符串对象的多次引用是安全的。字符串串联操作产生一个包含串联值的新字符串对象。不修改原始字符串对象。</p><p>C# 不保证垃圾回收器何时执行，甚至不保证是否执行。当垃圾回收器运行时，可能不会收集任何对象或只收集符合条件的对象的子集。</p><p>静态的方法不能直接访问非静态类成员，因为即使不存在类的对象，也可以调用静态方法。<code>this</code>引用不能在静态方法中使用。</p><h3 id="106只读实例变量"><a class="markdownIt-Anchor" href="#106只读实例变量"></a> 10.6.只读实例变量</h3><p>&quot;最起码&quot;原则<code>principle of least privilege</code>规定，应仅授予代码完成其指定任务所需的权限和访问权限，而不应授予更多权限。</p><p>使用<code>const</code>声明的常量在声明时必须初始化为常量值。</p><p>C# 提供关键字<code>readonly</code>，以指定对象的实例变量不可修改，并且在构造对象后修改它的任何尝试都是错误。</p><p>与常量一样，只读变量按约定用所有大写字母声明。在声明只读实例变量时，可以初始化它们，但这不是必需的。</p><p>在构造函数完成执行之前，只读实例变量不会变得不可修改。</p><p>必须在编译时为声明为<code>const</code>的成员分配值，而使用关键字<code>readonly</code>声明的成员可以在执行时初始化。只能读取的变量可以使用非函数的表达式（如数组初始化器或方法调用）初始化。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">int</span> NUMBER;</span><br><span class="line">NUMBER = <span class="number">1</span>;	<span class="comment">// 只可初始化一次</span></span><br></pre></td></tr></table></figure><p>如果类提供多个构造函数，则每个构造函数应初始化一个只读变量。 如果构造函数未初始化只读变量，则变量接收的默认值与任何其他实例变量相同，编译器将生成警告。</p><p>如果只读实例变量仅在其声明中初始化为常量，则不必为类的每个对象单独复制实例变量。应改为<code>const</code>常量。使用<code>const</code>声明的常量是隐式静态的，因此整个类将只有一个副本。</p><h3 id="107软件可复用性"><a class="markdownIt-Anchor" href="#107软件可复用性"></a> 10.7.软件可复用性</h3><p>软件可复用性<code>Software Reusability</code>加快了强大、高质量的软件的发展。快速应用程序开发（RAD）<code>Rapid Application Development</code>在今天引起了极大的关注。</p><p>避免重新发明车轮。如果库包含满足应用程序要求的类，则使用该类，而不是创建自己的类。</p><h3 id="108数据抽象和封装"><a class="markdownIt-Anchor" href="#108数据抽象和封装"></a> 10.8.数据抽象和封装</h3><p>类通常从客户端隐藏其实现的详细信息。这称为信息隐藏<code>information hiding</code>。</p><p>客户端关心的是类提供的功能，而不关心该功能是如何实现的。这个概念被称为数据抽象<code>data abstraction</code>。</p><p>抽象数据类型<code>Abstract Data Types</code>(ADT)实际上捕获两个概念：数据表示<code>data representation</code>和可对该数据执行的操作<code>operations</code>。</p><p>C# 程序员使用类来实现抽象数据类型。</p><h3 id="109内部访问"><a class="markdownIt-Anchor" href="#109内部访问"></a> 10.9.内部访问</h3><p>嵌套类<code>nested classes</code>：在其他类中定义的类。嵌套类也可以声明为<code>private</code>或<code>protected</code>。</p><p>如果类声明中没有访问修改器，则类默认为内部访问<code>internal access</code>。</p><p>内部访问允许类由与类相同的程序集<code>assembly</code>中的所有代码使用，但不允许其他程序集中的代码使用。声明为<code>interal</code>的类中方法、实例变量和其他成员只能被同一程序集中编译的所有代码访问。</p><h3 id="1010对象的初始化"><a class="markdownIt-Anchor" href="#1010对象的初始化"></a> 10.10.对象的初始化</h3><p>每个属性名称只能出现在对象初始化器列表<code>object-initializer list</code>。对象初始化器列表不能为空。</p><p>对象初始化器按其显示顺序执行属性初始化器。对象初始化器首先调用类的构造函数，因此构造函数为对象初始化器列表中未指定的任何值指定其值。</p><p>可以使用扩展方法<code>extension methods</code>向现有类添加功能，而无需修改类的源代码。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisPlayTime</span> (<span class="params"><span class="keyword">this</span> Time time</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展方法的第一个参数之前的 this 关键字通知编译器该方法扩展了现有类。扩展方法在类的对象上调用，该对象扩展该对象时，它就像它是类的成员一样。编译器隐式传递用于调用 方法作为扩展方法的第一个参数的对象。</p><p>扩展方法的第一个参数的类型指定正在扩展的类 — 扩展方法必须至少定义一个参数。扩展方法必须定义为静态顶级类中的静态方法。</p><p>扩展方法以及实例方法允许级联方法调用<code>cascaded method calls</code>，即在同一语句中调用多个方法。从左到右来执行级联方法调用。</p><p>使用完全限定的方法名称调用扩展方法时，必须为扩展方法的第一个参数指定参数。这种对扩展方法的使用类似于对静态方法的调用。</p><p>如果要扩展的类型定义了一个实例方法，该方法与扩展方法的名称相同且签名兼容<code>compatible signature</code>，那么实例方法将隐藏扩展方法。</p><p><strong>什么是委托？</strong></p><p>委托<code>delegate</code>是保存对方法的引用的对象。委托允许将方法视为数据 — 通过委托，可以将方法分配给变量，并将方法传递给其他方法。</p><p>还可以通过委托类型的变量调用方法。委托类型通过准备带有关键字<code>delegate</code>的方法头method header（放置在任何访问指定器之后，如 public ），来完成声明。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">DelFunction</span> (<span class="params"><span class="keyword">int</span> number</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">DelFunction delFunction = IsRight;</span><br><span class="line">delFunction(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseDel</span> (<span class="params">DelFunction delFunction</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsRight</span> (<span class="params"><span class="keyword">int</span> number</span>)</span>  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1011lambda表达式"><a class="markdownIt-Anchor" href="#1011lambda表达式"></a> 10.11.Lambda表达式</h3><p>Lambda 表达式<code>Lambda expressions</code>允许定义简单的匿名函数<code>anonymous functions</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DelFunction delfunction = </span><br><span class="line">    number =&gt; &#123;number %= <span class="number">2</span>; <span class="keyword">return</span> number;&#125;;</span><br></pre></td></tr></table></figure><p>lambda 表达式以参数列表开头，该列表后跟 lambda 运算符 lambda operator <code>=&gt;</code>和表示函数正文的表达式。</p><p>表达式产生的值由 lambda 表达式隐式返回。 可以从返回值推断返回类型，或者在某些情况下从委托的返回类型推断返回类型。 委托可以保存对 lambda 表达式的引用，该 lambda 表达式的签名与委托类型兼容。Lambda 表达式通常用作具有委托类型参数的方法的参数，而不是定义和引用单独的方法。</p><p>可以通过其引用的变量调用 lambda 表达式。lambda 表达式在 lambda 运算符的右侧称为表达式 lambdas<code>expression lambdas</code>。</p><p>Lambda 表达式可帮助减少代码的大小和使用委托的复杂性。</p><h3 id="1012匿名类型"><a class="markdownIt-Anchor" href="#1012匿名类型"></a> 10.12.匿名类型</h3><p>匿名类型<code>anonymous types</code>允许创建用于存储数据的简单类，而无需编写类定义。</p><p>匿名类型声明以关键字<code>new</code>开头，后跟大括号<code>&#123;&#125;</code>中的成员初始化器列表<code>member-initializer list</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sam = <span class="keyword">new</span> &#123; name = <span class="string">&quot;Sam Kong&quot;</span>, age = <span class="number">21</span> &#125;;</span><br></pre></td></tr></table></figure><p>编译器生成一个新的类定义，其中包含成员初始化器列表中指定的属性。匿名类型的所有属性都是公共的和不可变的。匿名类型属性是只读的，创建对象后不能修改属性的值。</p><p>由于它们是匿名的，因此必须使用隐式键入的局部变量来引用匿名类型的对象。</p><p>两个匿名对象，指定相同的属性名称和类型，以相同的顺序，使用相同的匿名类定义，并被视为同一类型。</p><h2 id="11继承"><a class="markdownIt-Anchor" href="#11继承"></a> 11.继承</h2><p>继承<code>inheritance</code>允许新类吸收现有类的成员。派生类<code>derived class</code>通常添加自己的字段和方法，以表示更专业化的对象组。继承通过重复使用经过验证的高质量软件来节省时间。</p><h3 id="111基类和派生类"><a class="markdownIt-Anchor" href="#111基类和派生类"></a> 11.1.基类和派生类</h3><p>直接基类<code>direct base class</code>是派生类显式继承的基类。间接基类<code>indirect base class</code>是类层次结构<code>class hierarchy</code>中直接基类之上的任何类。类层次结构从类对象开始。</p><p><code>is-a relationship</code>表示继承。</p><p>扩展公共基类的所有类的对象都可以被视为该基类的对象。但是，基类对象不能被视为其派生类的对象。当派生类需要继承方法的自定义版本时，派生类可以重写<code>override</code>基类方法。</p><h3 id="112受保护成员"><a class="markdownIt-Anchor" href="#112受保护成员"></a> 11.2.受保护成员</h3><p>基类的私有成员由派生类继承，但派生类方法和属性不能直接访问。</p><p>基类的受保护<code>protected</code>成员可由该基类的成员及其派生类的成员访问。基类的受保护内部<code>protected internal</code>成员可由基类的成员、派生类和同一程序集中的任何类访问。</p><p>派生类的属性和方法不能直接访问基类的私有成员。派生类只能通过基类中提供的非私有方法和属性来更改私有基类字段的状态。</p><h3 id="113基类和派生类的关系"><a class="markdownIt-Anchor" href="#113基类和派生类的关系"></a> 11.3.基类和派生类的关系</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 C# 类直接或间接继承<code>Object</code>的方法。 如果类未指定它继承自另一个类，它将隐式继承<code>Object</code>。</p><p>构造函数不会继承。</p><p>类<code>Object</code>的默认（空）构造函数不对任何操作。即使类没有构造函数，默认构造函数也会调用基类的默认或无参数构造函数。</p><p>使用其他访问修改器重写方法是编译错误。如果公共方法可以重写为受保护<code>protected</code>或私有<code>private</code>方法，则派生类对象不会响应与基类对象相同的方法调用。</p><p>使用受保护的实例变量会产生几个潜在的问题。</p><ul><li>派生类对象可以直接设置继承变量的值，而无需有效性检查。</li><li>需要编写派生类方法以依赖于基类的数据实现。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span> (<span class="params"><span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">base</span>.Display(name);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在派生类中重写基类方法时，派生类版本通常调用基类版本来执行部分工作。引用基类的方法时，如果未能使用关键字<code>base</code>对基类方法名称进行前缀，将派生类方法调用自身。</p><p>使用&quot;链式&quot;<code>base</code>引用来引用成员层次结构上的几个级别，如 base.base.Earnings ()，是一个编译错误。</p><h3 id="114派生类中的构造方法"><a class="markdownIt-Anchor" href="#114派生类中的构造方法"></a> 11.4.派生类中的构造方法</h3><p>派生类构造函数在执行自己的任务之前调用其直接基类的构造函数。如果基类派生自另一个类，则基类构造函数将调用层次结构中下一个类的构造函数，等等。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span> (<span class="params"><span class="keyword">string</span> name, <span class="keyword">int</span> age</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span> (<span class="params"><span class="keyword">string</span> name, <span class="keyword">int</span> age, <span class="keyword">double</span> score</span>) : <span class="title">base</span> (<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="115继承在软件工程中的作用"><a class="markdownIt-Anchor" href="#115继承在软件工程中的作用"></a> 11.5.继承在软件工程中的作用</h3><p>当新类扩展现有类时，新类将继承现有类的成员。</p><p>我们可以自定义新类，通过包括其他成员和覆盖基类成员来满足我们的需求。</p><p>独立软件供应商 Independent software vendors（ISV）可以开发和销售专有类。然后，用户可以从这些库类派生新类，而无需访问源代码。</p><h3 id="116object类"><a class="markdownIt-Anchor" href="#116object类"></a> 11.6.Object类</h3><p>所有类都直接或间接地从<code>Object</code>类继承。</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%951.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Object%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%952.png" style="zoom:50%"><h2 id="12多态性-接口和运算符过载"><a class="markdownIt-Anchor" href="#12多态性-接口和运算符过载"></a> 12.多态性、接口和运算符过载</h2><h3 id="121多态性"><a class="markdownIt-Anchor" href="#121多态性"></a> 12.1.多态性</h3><p>多态性<code>polymorphism</code>使得能够编写处理在类层次结构中共享同一基类的对象的应用程序，就像它们都是基类的对象一样。多态性可以提高可扩展性。</p><p>当应用程序通过基类变量调用方法时，将发生多态性。</p><p>多态性促进可扩展性<code>extensibility</code>：调用多态行为的软件独立于消息发送到的对象类型。仅需修改实例化新对象的客户端代码，就可以适应新类型。</p><p>在对对象进行方法调用时，实际引用对象的类型（而不是引用的类型）决定了调用的方法。</p><p>派生类的对象可以被视为其基类的对象，但基类对象不是其任何派生类的对象。</p><p>如果我们显式将基类引强制转换到派生类类型，编译器允许将基类引用分配给派生类变量。如果应用程序需要对基类变量引用的派生类对象执行派生类特定的操作，则必须将基类引用向下转换<code>downcasted</code>到派生类引用。</p><p>当编译器遇到通过变量进行的方法调用时，它通过检查变量的类类型确定是否可以调用该方法。在执行时，变量引用的对象的类型确定了要使用的实际方法。</p><h3 id="122抽象类和抽象方法"><a class="markdownIt-Anchor" href="#122抽象类和抽象方法"></a> 12.2.抽象类和抽象方法</h3><p>抽象类<code>abstract classes</code>或抽象基类<code>abstract base classes</code>不能用于实例化对象。抽象基类太笼统了，不能创建实际对象，它们只指定派生类之间的常见内容。</p><p>可用于实例化对象的类称为具体类<code>concrete classes</code>。具体类提供使实例化对象合理化的具体细节。</p><p>抽象类通常包含一个或多个抽象方法<code>abstract methods</code>，这些方法的宣言中包含关键字<code>bastract</code>。包含抽象方法的类必须声明为抽象类，即使它包含具体（非抽象）方法。抽象方法不提供实现。</p><p>抽象属性可以省略 get 访问器和 set 访问器的实现。具体派生类必须为抽象属性中声明的每个访问器提供实现。</p><p>构造函数和静态方法不能声明为抽象方法。</p><p>抽象类通常包含一个或多个抽象方法或属性，这些方法或属性，具体派生类必须重写。</p><p>我们可以使用抽象基类来声明变量，这些变量可以保存对从这些抽象类派生的任何具体类对象的引用。可以使用此类变量多态地操作派生类对象，并调用在这些抽象基类中声明的静态方法。在面向对象的编程中，通常声明一个可以遍历集合中所有对象的遍历器类<code>iterator class</code>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">abstract</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> name &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            name = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 确保对象与类有has-a关系，否则强制转换将引起异常</span></span><br><span class="line"><span class="keyword">if</span> (person <span class="keyword">is</span> Student) &#123;</span><br><span class="line">    Student student = (Student) person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将基类变量分配给派生类变量（没有显式向下转换）是编译错误。</p><p>如果在执行时，对派生类对象的引用已分配给其直接或间接基类之一的变量，则可以将存储在该基类变量中的引用转换回派生类类型的引用。在执行此类强制转换之前，使用<code>is</code>运算符确保对象确实是相应派生类类型的对象。对象只能强制转换到其自己的类型或其基类之一的类型。</p><p>通过使用<code>as</code>运算符执行向下转换而不是强制转换运算符，可以避免潜在的<code>InvalidCastException</code>。此时如果向下转换无效，则表达式将为 null，而不是引发异常。</p><p>将派生类引用分配给基类变量是安全的，因为派生类对象是基类的对象。但是，此引用只能引用基类成员。</p><h3 id="123密封类和密封方法"><a class="markdownIt-Anchor" href="#123密封类和密封方法"></a> 12.3.密封类和密封方法</h3><p>在基类中声明密封<code>sealed</code>的方法不能在派生类中重写。声明为私有<code>private</code>的方法是隐式密封<code>sealed</code>的。</p><p>声明静态的方法也是隐式密封的，因为静态方法也不能被重写。</p><p>同时声明为重写和密封的派生类方法可以重写基类方法，但不能在继承层次结构下更高级的类中重写。</p><p>对密封方法的调用在编译时解析 - 这称为静态绑定<code>static binding</code>。</p><h3 id="124接口"><a class="markdownIt-Anchor" href="#124接口"></a> 12.4.接口</h3><p>接口<code>interfaces</code>定义并标准化了人与系统相互交互的方式。</p><p>C# 接口描述了一组可以在对象上调用的方法，例如告诉对象执行某些任务或返回某些信息。接口声明从关键字接口开始，只能包含抽象方法、属性、索引和事件。</p><p>所有接口成员都隐式声明为公共和抽象。接口可以扩展一个或多个其他接口，以创建其他类可以实现的更精细的接口。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICalculateScore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetScore</span> (<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IInformStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">GetStudentEmail</span> (<span class="params"><span class="keyword">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span> : <span class="title">IcalculateScore</span>, <span class="title">IInformStudent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetScore</span> (<span class="params"><span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">GetStudentEmail</span> (<span class="params"><span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口的具体类必须使用接口声明中指定的签名声明接口的每个成员。实现接口但未实现其所有成员的类是抽象类，它必须声明为抽象类，并且必须包含接口的每个未实现成员的抽象声明。</p><p>当不同的（即不相关的）类需要共享通用方法以便可以多态处理它们时，通常使用接口。</p><p>程序员可以创建描述所需功能的接口，然后在任何需要该功能的类中实现此接口。当没有要继承的默认实现时，通常使用接口代替抽象类，即没有字段和默认方法实现。</p><p>与抽象类一样，接口通常是公共类型，因此它们通常由与接口和 .cs 文件名扩展名相同的名称在文件中声明。</p><p>UML 通过<code>realization</code>表示类和接口之间的关系。</p><p>C# 不允许派生类从多个基类继承，但它允许类实现任何数量的接口。当类从基类继承并实现一个或多个接口时，类声明必须在任何接口名称之前列出基类名称。</p><p>继承和接口在实现 is-a 关系时是相似的。实现接口的类的对象可被视为该接口类型的对象。基类和派生类之间存在的 is-a 关系，以及接口和实现它们的类之间存在的关系，在将对象传递到方法时保持。</p><p>可以使用接口类型的引用调用<code>Object</code>类的所有方法 - 引用指向了一个对象，而所有对象都继承了<code>Object</code>的方法。</p><p>.NET 框架类库的通用接口：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/.NET%E6%A1%86%E6%9E%B6%E7%B1%BB%E5%BA%93%E7%9A%84%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3.png" style="zoom:50%"><h3 id="125运算符过载"><a class="markdownIt-Anchor" href="#125运算符过载"></a> 12.5.运算符过载</h3><p>关键字<code>operator</code>，后跟运算符符号，表示方法重载指定的运算符。</p><p>重载二进制运算符的方法必须采用两个参数 — 第一个参数是左操作数，第二个参数是右操作数。</p><p>重载运算符方法必须是公共的和静态的。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Mate</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Marry <span class="keyword">operator</span> + (Person husband, Person wife) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13异常处理"><a class="markdownIt-Anchor" href="#13异常处理"></a> 13.异常处理</h2><p>异常<code>exception</code>表示在程序执行期间出现问题。异常处理<code>exception handling</code>使应用程序能够解决异常。异常处理可实现清晰、可靠<code>robust</code>和更多容错的程序<code>fault-tolerant programs</code>。</p><h3 id="131try-catch语句块"><a class="markdownIt-Anchor" href="#131try-catch语句块"></a> 13.1.try-catch语句块</h3><p><code>try</code>块包含可能会引发异常的代码，以及发生异常时跳过的代码。</p><p>当 try 块中发生异常时，相应的<code>catch</code>块捕获异常并处理它。 至少必须得有一个捕获块立即跟随 try 块。catch 块指定一个异常参数，表示 catch 块可以处理的异常。也可以包括一个不指定异常类型的 catch 块来捕获所有异常类型。</p><p>catch 块最多只能有一个参数。</p><h3 id="132异常处理的终止模型"><a class="markdownIt-Anchor" href="#132异常处理的终止模型"></a> 13.2.异常处理的终止模型</h3><p>当在程序或 CLR 中调用的方法检测到问题时，该方法或 CLR 引发异常。发生异常的点称为引发点<code>throw point</code>。</p><p>如果 try 块中发生异常，程序控制会立即转移到与引发异常类型匹配的第一个 catch 块。处理异常后，程序控制将在最后一个 catch 块之后恢复。</p><p>这称为异常处理的终止模型<code>termination model of exception handling</code>。</p><h3 id="133net异常层次结构"><a class="markdownIt-Anchor" href="#133net异常层次结构"></a> 13.3.NET异常层次结构</h3><p>在 C# 中，只有<code>Exception</code>类及其派生类的对象能被抛出和捕获。</p><p>如果捕获基类异常的 catch 块被放置在该类的任何派生类类型的 catch 块之前，编译器将引发错误。在这种情况下，基类 catch 块将捕获所有基类和派生类异常，因此派生类异常处理程序永远不会执行。</p><p>如果捕获基类异常的 catch 块被放置在该类的任何派生类类型的 catch 块之前，编译器将引发错误。在这种情况下，基类 catch 块将捕获所有基类和派生类异常，因此派生类异常处理程序永远不会执行。</p><p>如果方法引发异常，则直接或间接调用该方法的语句应放在 try 块中，并且应捕获和处理这些异常。</p><h3 id="134finally语句块"><a class="markdownIt-Anchor" href="#134finally语句块"></a> 13.4.finally语句块</h3><p>C# 提供<code>finally</code>块，无论发生异常，都保证执行。 这使得 finally 块非常适合从相应的 try 块释放资源。</p><p>在相应的 finally 块中无法访问 try 块中的局部变量，因此应在 try 块之前声明必须在这两个块中访问的变量。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Expection exceptionParameter) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果最后块执行时正在等待处理未捕获的异常，并且 finally 块将引发未在 finally 块中捕获的新异常，则第一个异常将丢失，并且新异常将传递到下一个封闭 try 块。</p><h3 id="135exception类的属性"><a class="markdownIt-Anchor" href="#135exception类的属性"></a> 13.5.Exception类的属性</h3><ul><li><p>属性<code>Message</code>存储与异常对象关联的错误消息。</p></li><li><p>属性<code>StackTrace</code>包含一个表示方法调用堆栈的字符串，包含了引发点的方法调用堆栈的状态。内部异常信息包括内部异常堆栈跟踪。</p></li><li><p>原始异常对象存储在<code>InnerException</code>属性中。</p></li><li><p><code>HelpLink</code>指定描述问题的帮助文件的位置。</p></li><li><p><code>Source</code>指定导致异常的应用程序或对象的名称。</p></li><li><p><code>TargetSite</code>指定异常发生的方法。</p></li></ul><p>最近调用的方法显示在堆栈的顶部，第一种方法（主方法）显示在底部。</p><h3 id="136用户定义的异常类"><a class="markdownIt-Anchor" href="#136用户定义的异常类"></a> 13.6.用户定义的异常类</h3><p>用户定义的异常类<code>user-defined exception classes</code>应直接或间接派生自命名空间系统的<code>Exception</code>类。</p><p>用户定义的异常应定义三个构造函数：</p><ul><li>无参数构造函数</li><li>接收字符串参数的构造函数（错误消息）</li><li>接收字符串参数和<code>Expception</code>参数（错误消息和内部异常对象）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyException</span> : <span class="title">Exception</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span> (<span class="params"></span>) : <span class="title">base</span> (<span class="params"><span class="string">&quot;我定义的异常&quot;</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// empty body</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span> (<span class="params"><span class="keyword">string</span> messageValue</span>) : <span class="title">base</span> (<span class="params">messageValue</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// empty body</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span> (<span class="params"><span class="keyword">string</span> messageValue, Exception inner</span>) : <span class="title">base</span> (<span class="params">messageValue, inner</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// empty body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14winform窗体"><a class="markdownIt-Anchor" href="#14winform窗体"></a> 14.WinForm窗体</h2><p>图形用户界面 （GUI） 允许用户与程序进行视觉交互。</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%9A%84GUI%E6%8E%A7%E4%BB%B6.png" style="zoom:50%"><h3 id="141windows窗体"><a class="markdownIt-Anchor" href="#141windows窗体"></a> 14.1.Windows窗体</h3><p>组件<code>component</code>是实现<code>IComponent interface</code>的类的实例，该接口定义组件必须实现的行为，例如组件的加载方法。</p><p>当用户单击窗口内某处时，窗口将成为活动窗口。窗体<code>Form</code>是控件和组件的容器<code>container</code>。</p><p>常见的窗体属性、方法、和事件：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AA%97%E4%BD%93%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E4%BA%8B%E4%BB%B61.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AA%97%E4%BD%93%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E4%BA%8B%E4%BB%B62.png" style="zoom:50%"><h3 id="142事件处理"><a class="markdownIt-Anchor" href="#142事件处理"></a> 14.2.事件处理</h3><p>GUI 是事件驱动<code>event driven</code>的。当用户与 GUI 组件交互时，事件将驱动程序执行任务。执行任务以响应事件的方法称为事件处理程序<code>event handler</code>。</p><p>每个事件处理程序接收两个参数时：</p><ul><li>名为 sender 的对象引用 — 对生成事件的对象的引用。</li><li>对 EventArgs 类型对象的引用，其中包含有关事件的其他信息。</li></ul><p>不应期望从事件处理程序返回值 - 事件 处理程序旨在执行基于操作的代码，将控制权返回到主程序。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ExampleForm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ExampleForm</span> : <span class="title">Form</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExampleForm</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ClickButton_Click</span> (<span class="params">Object sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">            MessageBox.Show(<span class="string">&quot;一个例子&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改器<code>partial</code>允许将窗体的类拆分为多个文件。</p><p>方法<code>InitializeComponent</code>在创建窗体时调用。</p><p>事件处理程序通过称为委托<code>delegates</code>的特殊对象连接到控件的事件。委托对象保存对方法的引用。</p><p>类型<code>EventHandler</code>的委托必须返回 void，并接收两个参数 - 一个<code>Object</code>类型和一个<code>EventArgs</code>类型：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span> (<span class="params">Object sender, EventArge e</span>)</span>;</span><br></pre></td></tr></table></figure><p>委托的工作是调用适当的方法。向事件添加更多委托称为多播委托<code>multicast delegates</code>。</p><h3 id="143control的属性和布局"><a class="markdownIt-Anchor" href="#143control的属性和布局"></a> 14.3.Control的属性和布局</h3><p><code>Control</code>的属性和方法：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Control%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%951.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Control%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%952.png" style="zoom:50%"><p><code>Anchoring</code>使控件保持与容器两侧的固定距离。</p><p>窗体的<code>Padding</code>属性指定停靠控件和边之间的距离。</p><p><code>Docking</code>允许控件跨越其父容器的整个一侧或填充整个容器</p><p>Control 类的布局属性：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Control%E7%B1%BB%E7%9A%84%E5%B8%83%E5%B1%80%E5%B1%9E%E6%80%A7.png" style="zoom:50%"><h3 id="144标签-文本框和按钮"><a class="markdownIt-Anchor" href="#144标签-文本框和按钮"></a> 14.4.标签、文本框和按钮</h3><p><code>Label</code>的属性：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Label%E7%9A%84%E5%B1%9E%E6%80%A7.png" style="zoom:50%"><p><code>TextBox</code>的属性和事件：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/TextBox%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E4%BB%B6.png" style="zoom:50%"><p>文本框<code>TextBox</code>是一个区域，其中任何一个文本都可以由程序显示，或者用户可以通过键盘键入文本。如果将属性<code>UseSystemPasswordChar</code>设置为 True，则文本框将变为密码文本框。</p><p><code>Button</code>的属性和事件：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Button%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E4%BB%B6.png" style="zoom:50%"><p>尽管标签、文本框和其他控件可以响应鼠标单击，但按钮在此用途下更为自然。</p><h3 id="145groupboxes-and-panels"><a class="markdownIt-Anchor" href="#145groupboxes-and-panels"></a> 14.5.GroupBoxes and Panels</h3><p><code>GroupBoxes</code>和<code>Panels</code>在 GUI 上排列相关控件，可以包含其他面板<code>Panels</code>和更复杂布局的组框<code>GroupBoxes</code>。</p><p>移动 GroupBox 或 Panels 时，组框或面板中的所有控件将一起移动。主要区别在于 GroupBox 可以显示标题，并且不包括滚动条，而 Panels 可以包含滚动条，并且不包括标题。</p><p>GroupBox的属性：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/GroupBox%E7%9A%84%E5%B1%9E%E6%80%A7.png" style="zoom:50%"><p>Panel的属性：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Panel%E7%9A%84%E5%B1%9E%E6%80%A7.png" style="zoom:50%"><h3 id="146checkboxes-and-radiobuttons"><a class="markdownIt-Anchor" href="#146checkboxes-and-radiobuttons"></a> 14.6.CheckBoxes and RadioButtons</h3><p><code>CheckBox</code>的属性和事件：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/CheckBox%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E4%BB%B6.png" style="zoom:50%"><p>复选框<code>CheckBoxes</code>是一个小方块，可以是空的，也可以是包含一个检查标记。</p><p>还可以配置 CheckBox，通过将<code>Three­State</code>属性设置为 True 来在三种状态之间切换。一次可以选择任何数量的复选框。</p><p><code>RadoiButton</code>的属性和事件：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/RadioButton%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E4%BB%B6.png" style="zoom:50%"><p>单选按钮<code>RadioButtons</code>与 CheckBox 类似，因为它们也有两种状态 - 已选择和未选中。</p><p>RadioButtons 通常显示为一个组，一次只能选择一个 RadioButton。添加到容器的所有 RadioButtons 都成为同一组的一部分。</p><h3 id="147pictureboxes"><a class="markdownIt-Anchor" href="#147pictureboxes"></a> 14.7.PictureBoxes</h3><p><code>PictureBox</code>的属性和事件：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/PictureBoxes%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E4%BB%B6.png" style="zoom:50%"><h3 id="148tooltips"><a class="markdownIt-Anchor" href="#148tooltips"></a> 14.8.ToolTips</h3><p>当鼠标悬停在 GUI 中的项目上时，<code>ToolTips</code>是显示的有用文本。</p><p><code>ToolTip</code>的属性和事件：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/ToolTip%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E4%BB%B6.png" style="zoom:50%"><h3 id="149numericupdown-control"><a class="markdownIt-Anchor" href="#149numericupdown-control"></a> 14.9.NumericUpDown Control</h3><p>可以使用<code>NumericUpDown Control</code>将用户的输入选项限制为特定范围内的数值。用户可以在此控件中键入数值或单击向上和向下箭头。</p><p><code>NumbericUpDown</code>的属性和事件：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/NumbericUpDown%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BA%8B%E4%BB%B6.png" style="zoom:50%"><p>NumericUpDown 的<code>ReadOnly</code>属性设置为 true 时，用户不能在控件中键入数字。</p><h3 id="1410鼠标事件处理"><a class="markdownIt-Anchor" href="#1410鼠标事件处理"></a> 14.10.鼠标事件处理</h3><p>当用户通过鼠标与控件交互时，将生成鼠标事件<code>Mouse events</code>。有关事件的信息通过 MouseEventArgs 对象传递，委托类型为 MouseEventHandler。</p><p>鼠标事件和事件参数：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%B8%96%E5%AE%B6%E5%8F%82%E6%95%B01.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%B8%96%E5%AE%B6%E5%8F%82%E6%95%B02.png" style="zoom:50%"><h3 id="1411键盘事件处理"><a class="markdownIt-Anchor" href="#1411键盘事件处理"></a> 14.11.键盘事件处理</h3><p>有三种key事件：</p><ul><li>当用户按下表示 ASCII 字符的键时，将发生 KeyPress 事件。</li><li>KeyPress 事件不指示是否按下了修改键（例如 Shift、Alt 和 Ctrl）；</li><li>如果此信息很重要，可以使用 KeyUp 或 KeyDown 事件。</li></ul><p>键盘事件和事件参数：</p><img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B01.png" style="zoom:50%"> <img src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B02.png" style="zoom:50%"><p>若要在窗体上按下 Enter 键时单击按钮，请设置窗体的<code>AcceptButton</code>属性 。</p></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">MinGo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://the-mingo.club/post/8f51f577.html">http://the-mingo.club/post/8f51f577.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://the-mingo.club" target="_blank">MinGoBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/">电子商务</a><a class="post-meta__tags" href="/tags/C/">C#</a></div><div class="post_share"><div class="social-share" data-image="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-top-img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2b02fdec.html"><img class="prev-cover" src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-top-img.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">人工智能</div></div></a></div><div class="next-post pull-right"><a href="/post/a8e83d78.html"><img class="next-cover" src="https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E6%A0%91%E8%8E%93%E6%B4%BE4b-%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5/%E6%A0%91%E8%8E%93%E6%B4%BE4b-%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5-top-img.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">树莓派4b语音播报</div></div></a></div></nav></article></main><footer id="footer" style="background-image:url(https://mingoblogimages-1302757742.cos.ap-shanghai.myqcloud.com/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0-top-img.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By MinGo</div><div class="footer_custom_text">MinGo的个人创作</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading=function(){document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")};window.addEventListener("load",endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/click_heart.js" async></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.6},dialog:{enable:!0,hitokoto:!0},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>